$date
	Sat Dec 21 02:52:14 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module subtractionTB $end
$var wire 1 ! overflow $end
$var wire 4 " Y [3:0] $end
$var wire 1 # BorrowOut $end
$var reg 4 $ A [3:0] $end
$var reg 4 % B [3:0] $end
$var reg 1 & BorrowIN $end
$scope module uut $end
$var wire 4 ' A [3:0] $end
$var wire 4 ( B [3:0] $end
$var wire 1 & BorrowIN $end
$var wire 4 ) tempB [3:0] $end
$var wire 1 ! overflow $end
$var wire 4 * Y [3:0] $end
$var wire 1 # BorrowOut $end
$scope module f0 $end
$var wire 1 + A $end
$var wire 1 , B $end
$var wire 1 & BorrowIN $end
$var wire 1 - BorrowOut $end
$var wire 1 . tempD $end
$var wire 1 / tempB2 $end
$var wire 1 0 tempB1 $end
$var wire 1 1 Difference $end
$scope module hf1 $end
$var wire 1 + A $end
$var wire 1 , B $end
$var wire 1 0 Borrow $end
$var wire 1 . Difference $end
$var wire 1 2 notA $end
$upscope $end
$scope module hf2 $end
$var wire 1 . A $end
$var wire 1 & B $end
$var wire 1 / Borrow $end
$var wire 1 1 Difference $end
$var wire 1 3 notA $end
$upscope $end
$upscope $end
$scope module f1 $end
$var wire 1 4 A $end
$var wire 1 5 B $end
$var wire 1 6 BorrowIN $end
$var wire 1 7 BorrowOut $end
$var wire 1 8 tempD $end
$var wire 1 9 tempB2 $end
$var wire 1 : tempB1 $end
$var wire 1 ; Difference $end
$scope module hf1 $end
$var wire 1 4 A $end
$var wire 1 5 B $end
$var wire 1 : Borrow $end
$var wire 1 8 Difference $end
$var wire 1 < notA $end
$upscope $end
$scope module hf2 $end
$var wire 1 8 A $end
$var wire 1 6 B $end
$var wire 1 9 Borrow $end
$var wire 1 ; Difference $end
$var wire 1 = notA $end
$upscope $end
$upscope $end
$scope module f2 $end
$var wire 1 > A $end
$var wire 1 ? B $end
$var wire 1 @ BorrowIN $end
$var wire 1 A BorrowOut $end
$var wire 1 B tempD $end
$var wire 1 C tempB2 $end
$var wire 1 D tempB1 $end
$var wire 1 E Difference $end
$scope module hf1 $end
$var wire 1 > A $end
$var wire 1 ? B $end
$var wire 1 D Borrow $end
$var wire 1 B Difference $end
$var wire 1 F notA $end
$upscope $end
$scope module hf2 $end
$var wire 1 B A $end
$var wire 1 @ B $end
$var wire 1 C Borrow $end
$var wire 1 E Difference $end
$var wire 1 G notA $end
$upscope $end
$upscope $end
$scope module f3 $end
$var wire 1 H A $end
$var wire 1 I B $end
$var wire 1 J BorrowIN $end
$var wire 1 # BorrowOut $end
$var wire 1 K tempD $end
$var wire 1 L tempB2 $end
$var wire 1 M tempB1 $end
$var wire 1 N Difference $end
$scope module hf1 $end
$var wire 1 H A $end
$var wire 1 I B $end
$var wire 1 M Borrow $end
$var wire 1 K Difference $end
$var wire 1 O notA $end
$upscope $end
$scope module hf2 $end
$var wire 1 K A $end
$var wire 1 J B $end
$var wire 1 L Borrow $end
$var wire 1 N Difference $end
$var wire 1 P notA $end
$upscope $end
$upscope $end
$scope module od1 $end
$var wire 4 Q A [3:0] $end
$var wire 4 R B [3:0] $end
$var wire 1 # CarryOUT $end
$var wire 4 S Y [3:0] $end
$var wire 1 T addOverflow $end
$var wire 1 U detect1 $end
$var wire 1 V detect2 $end
$var wire 1 W opC $end
$var wire 2 X opCode [1:0] $end
$var wire 1 ! overflowDetect $end
$var wire 1 Y sign1 $end
$var wire 1 Z sign2 $end
$var wire 1 [ sign3 $end
$var wire 1 \ subOverflow $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0\
0[
0Z
1Y
b10 X
1W
0V
0U
0T
b0 S
b0 R
b0 Q
1P
1O
0N
0M
0L
0K
0J
0I
0H
1G
1F
0E
0D
0C
0B
0A
0@
0?
0>
1=
1<
0;
0:
09
08
07
06
05
04
13
12
01
00
0/
0.
0-
0,
0+
b0 *
bz000 )
b0 (
b0 '
0&
b0 %
b0 $
0#
b0 "
0!
$end
#10
b100 "
b100 *
b100 S
1E
0G
0<
1B
0F
15
14
1>
b10 %
b10 (
b10 R
b110 $
b110 '
b110 Q
#20
1Z
1#
b1100 "
b1100 *
b1100 S
1N
1L
1J
bz100 )
1A
1D
1F
1?
0>
b110 %
b110 (
b110 R
b10 $
b10 '
b10 Q
#30
0!
0V
0J
0#
bz000 )
0A
0L
1U
0E
1G
0D
b1000 "
b1000 *
b1000 S
1N
0P
1\
1<
0B
0F
1K
0O
0Y
1[
0Z
05
04
1>
1H
b100 %
b100 (
b100 R
b1100 $
b1100 '
b1100 Q
#40
1Z
0U
b0 "
b0 *
b0 S
0N
1P
0\
0K
1Y
0[
1F
0?
1I
0>
b1000 %
b1000 (
b1000 R
b1000 $
b1000 '
b1000 Q
#50
0!
0Z
0V
1U
16
1N
0P
1\
0;
0=
1E
0G
bz001 )
1-
1K
0Y
1[
02
18
0<
1B
0F
b1101 "
b1101 *
b1101 S
11
1/
1,
0I
1+
14
1>
1&
b1 %
b1 (
b1 R
b1111 $
b1111 '
b1111 Q
#60
